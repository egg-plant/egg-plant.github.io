import React, {Component} from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import {darcula, docco} from 'react-syntax-highlighter/styles/hljs';

const SICP = () => (

    <div>
        <p>In this section we will cover one of the greatest books of all time on funcational programming Structure and
            Interpretation of Computer Programs (Gerald Jay Sussman and Hal Abelson). Please give us a chance to get
            onto this! </p>

        <h2>Building Abstractions with Procedures</h2>
        <h3>Elements of Programming</h3>
        <p>To build complex solutions in computers you need a programming language SICP focuses on using Scheme and we
            will use Clojure due to similarities. Clojure provides simple concepts that can be combined to build more
            complex solutions it does this by three main points: primitive expressions, means of combination and means
            of abstraction. A key point is made here we deal with two kinds of elements procedures and data and these
            are clearly separated at this point and are for functional progreamming but later on the book SICP says they
            become more entwined due to Object Oriented Programming. The first section of the book covers the basic of
            the language that we will skip here, but it does start to explain how to evaluate the code in a basic form
            of the substitution model, the operations values are substituted by the role and you can build up the end
            result using this method. Procdures should be black box operations hence the parameters passed in are local
            values to the procedure, in Clojure let can be used to define further local values to a procedure and you
            can use the block structure to structure these scopes and define sub procedures within procedures.</p>

        <h3>Procedures and the Processes they Generate</h3>
        <h4>Linear Recursion and Iteration</h4>
        <p>As programmers we need to be able to visualise the processes generated by the procedures that we write to
            ensure they work correctly and efficiently. This section discusses the shape of the process formed by
            procedures. The section uses factorial calculation to describe a linear recursive solution will expand out
            the calls of the function chaining them and then contracting as the functions are actually called.
            Alternatively a process that is iterative does not grow and contract but does keep state that is mutated but
            this enables the program to pick a certain part of the process and continue from that point. Remember we are
            talking about recursive processes here not recursive procedures.</p>
        <SyntaxHighlighter language='clojure' style={darcula} showLineNumbers={true} wrapLines={true}>{`(defn factorial
  [n]
  (if (= n 1 )
    1
    (* n (factorial (- n 1)))))`}</SyntaxHighlighter>
        <SyntaxHighlighter language='clojure' style={darcula} showLineNumbers={true} wrapLines={true}>{`(defn fact-iter
 [product counter max-count]
  (if (> counter max-count)
    product
    (fact-iter (* counter product)
               (inc counter)
               max-count)))

(defn factorial-linear
  [n]
  (fact-iter 1 1 n))`}</SyntaxHighlighter>

        <h4>Tree Recursion</h4>    <p>Another common patter of computation is tree recursion. The book uses fibonacci
        sequence to show this defined as each number is the sum of the previous two. The algorithm that is very simple
        is used here. </p>

        <SyntaxHighlighter language='clojure' style={darcula} showLineNumbers={true} wrapLines={true}>{`(defn fibinacci
  [n]
  (cond (= n 0) 0
        (= n 1) 1
        :else (+ (fibinacci (dec n))
                 (fibinacci (- n 2)))))`}</SyntaxHighlighter>
        <p>This solution can be pictured as a recursive tree where to compute (fib 5) we have to compute (fib 3) and
            (fib 4) and for (fib 4) we compute (fib 3) and (fib 2) and for (fib 3) we compuete (fib 2) and (fib 1). Now
            we can see the duplication!</p>

        <h3>Formulating Abstractions with Higher Order Procedures</h3>
        <p>We have seen that procedures can accept numeric parameters but Higher Order Procedures can accept accept
            other procedures as arguments or return these procedures. This ability allows us to reduce duplicated code
            immensely which is a great thing the book covers an example of summing integers and cubes. Mathematicians
            discovered the sum pattern many years ago and formed the Sigma notation to represent it. Rather than
            defining new functions each time you can use lambdas that are functions without a name (anonymous function).
            The ability to pass in procedures not only reduces duplication but can make procedures more flexible and
            clearer to read.</p>


        <h2>Building Abstractions with Data</h2>
        <h3>Introduction to Data Abstraction</h3>
        <p>Previously we discussed building abstractions with Compound Procedures now we are going to investigate the
            benefits of being able to combine data objects to build compound data. This ability enables us to deal with
            data at a higher conceptual level than that of primitive data. The isolation of how the system deals with
            how data is represented and how the system processes data is called data abstraction.</p>
        <p>Abstraction barriers are barriers that isolate the use of data abstractions from the barriers that implement
            them.</p>
        <h3>Hierarchical Data and the Closure Property</h3>
        <p></p>
        <h3>Symbolic Data</h3>
        <p></p>
        <h3>Multiple Representation for Abstract Data</h3>
        <p></p>
        <h3>Systems with Generic Operations</h3>
        <p></p>
    </div>


);

export default SICP;
